// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"strings"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"botApiStats/dal/model"
)

func newBotResponse(db *gorm.DB, opts ...gen.DOOption) botResponse {
	_botResponse := botResponse{}

	_botResponse.botResponseDo.UseDB(db, opts...)
	_botResponse.botResponseDo.UseModel(&model.BotResponse{})

	tableName := _botResponse.botResponseDo.TableName()
	_botResponse.ALL = field.NewAsterisk(tableName)
	_botResponse.ID = field.NewUint(tableName, "id")
	_botResponse.UnixTime = field.NewInt64(tableName, "unix_time")
	_botResponse.IntentId = field.NewString(tableName, "intent_id")
	_botResponse.IntentName = field.NewString(tableName, "intent_name")

	_botResponse.fillFieldMap()

	return _botResponse
}

type botResponse struct {
	botResponseDo

	ALL        field.Asterisk
	ID         field.Uint
	UnixTime   field.Int64
	IntentId   field.String
	IntentName field.String

	fieldMap map[string]field.Expr
}

func (b botResponse) Table(newTableName string) *botResponse {
	b.botResponseDo.UseTable(newTableName)
	return b.updateTableName(newTableName)
}

func (b botResponse) As(alias string) *botResponse {
	b.botResponseDo.DO = *(b.botResponseDo.As(alias).(*gen.DO))
	return b.updateTableName(alias)
}

func (b *botResponse) updateTableName(table string) *botResponse {
	b.ALL = field.NewAsterisk(table)
	b.ID = field.NewUint(table, "id")
	b.UnixTime = field.NewInt64(table, "unix_time")
	b.IntentId = field.NewString(table, "intent_id")
	b.IntentName = field.NewString(table, "intent_name")

	b.fillFieldMap()

	return b
}

func (b *botResponse) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := b.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (b *botResponse) fillFieldMap() {
	b.fieldMap = make(map[string]field.Expr, 4)
	b.fieldMap["id"] = b.ID
	b.fieldMap["unix_time"] = b.UnixTime
	b.fieldMap["intent_id"] = b.IntentId
	b.fieldMap["intent_name"] = b.IntentName
}

func (b botResponse) clone(db *gorm.DB) botResponse {
	b.botResponseDo.ReplaceConnPool(db.Statement.ConnPool)
	return b
}

func (b botResponse) replaceDB(db *gorm.DB) botResponse {
	b.botResponseDo.ReplaceDB(db)
	return b
}

type botResponseDo struct{ gen.DO }

type IBotResponseDo interface {
	gen.SubQuery
	Debug() IBotResponseDo
	WithContext(ctx context.Context) IBotResponseDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IBotResponseDo
	WriteDB() IBotResponseDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IBotResponseDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IBotResponseDo
	Not(conds ...gen.Condition) IBotResponseDo
	Or(conds ...gen.Condition) IBotResponseDo
	Select(conds ...field.Expr) IBotResponseDo
	Where(conds ...gen.Condition) IBotResponseDo
	Order(conds ...field.Expr) IBotResponseDo
	Distinct(cols ...field.Expr) IBotResponseDo
	Omit(cols ...field.Expr) IBotResponseDo
	Join(table schema.Tabler, on ...field.Expr) IBotResponseDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IBotResponseDo
	RightJoin(table schema.Tabler, on ...field.Expr) IBotResponseDo
	Group(cols ...field.Expr) IBotResponseDo
	Having(conds ...gen.Condition) IBotResponseDo
	Limit(limit int) IBotResponseDo
	Offset(offset int) IBotResponseDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IBotResponseDo
	Unscoped() IBotResponseDo
	Create(values ...*model.BotResponse) error
	CreateInBatches(values []*model.BotResponse, batchSize int) error
	Save(values ...*model.BotResponse) error
	First() (*model.BotResponse, error)
	Take() (*model.BotResponse, error)
	Last() (*model.BotResponse, error)
	Find() ([]*model.BotResponse, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.BotResponse, err error)
	FindInBatches(result *[]*model.BotResponse, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.BotResponse) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IBotResponseDo
	Assign(attrs ...field.AssignExpr) IBotResponseDo
	Joins(fields ...field.RelationField) IBotResponseDo
	Preload(fields ...field.RelationField) IBotResponseDo
	FirstOrInit() (*model.BotResponse, error)
	FirstOrCreate() (*model.BotResponse, error)
	FindByPage(offset int, limit int) (result []*model.BotResponse, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IBotResponseDo
	UnderlyingDB() *gorm.DB
	schema.Tabler

	FilterWithNameAndRole(name string, role string) (result []model.BotResponse, err error)
	SelectTopIntentId(n int) (result []map[string]interface{}, err error)
	SelectTopIntentIdByTime(startTime int64, endTime int64, n int) (result []map[string]interface{}, err error)
	GetIntentNameByIntentId(intentId string) (result string, err error)
	SelectTopIntentByDailyRank(startTime int64, endTime int64, n int) (result []map[string]interface{}, err error)
}

// SELECT * FROM @@table WHERE name = @name{{if role !=""}} AND role = @role{{end}}
func (b botResponseDo) FilterWithNameAndRole(name string, role string) (result []model.BotResponse, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, name)
	generateSQL.WriteString("SELECT * FROM bot_response WHERE name = ? ")
	if role != "" {
		params = append(params, role)
		generateSQL.WriteString("AND role = ? ")
	}

	var executeSQL *gorm.DB

	executeSQL = b.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result)
	err = executeSQL.Error
	return
}

// select intent_id, count(*) cnt from `bot_response` group by intent_id order by cnt desc limit @n
func (b botResponseDo) SelectTopIntentId(n int) (result []map[string]interface{}, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, n)
	generateSQL.WriteString("select intent_id, count(*) cnt from `bot_response` group by intent_id order by cnt desc limit ? ")

	var executeSQL *gorm.DB

	executeSQL = b.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result)
	err = executeSQL.Error
	return
}

// select intent_id, count(*) cnt,
// (select intent_name from bot_response where intent_id=br.intent_id  order by unix_time desc limit 1) as intent_name
// from `bot_response` br where unix_time between @startTime and @endTime group by intent_id order by cnt desc limit @n
func (b botResponseDo) SelectTopIntentIdByTime(startTime int64, endTime int64, n int) (result []map[string]interface{}, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, startTime)
	params = append(params, endTime)
	params = append(params, n)
	generateSQL.WriteString("select intent_id, count(*) cnt, (select intent_name from bot_response where intent_id=br.intent_id order by unix_time desc limit 1) as intent_name from `bot_response` br where unix_time between ? and ? group by intent_id order by cnt desc limit ? ")

	var executeSQL *gorm.DB

	executeSQL = b.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result)
	err = executeSQL.Error
	return
}

// select intent_name from bot_response where intent_id = @intentId order by created_at desc limit 1
func (b botResponseDo) GetIntentNameByIntentId(intentId string) (result string, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, intentId)
	generateSQL.WriteString("select intent_name from bot_response where intent_id = ? order by created_at desc limit 1 ")

	var executeSQL *gorm.DB

	executeSQL = b.UnderlyingDB().Raw(generateSQL.String(), params...).Take(&result)
	err = executeSQL.Error
	return
}

// select intent_id, sum(count) total_cnt,
// (select intent_name from bot_response where intent_id=di.intent_id order by unix_time desc limit 1) as intent_name
// from `daily_intent` di where unix_time between @startTime and @endTime group by intent_id order by total_cnt desc limit @n
func (b botResponseDo) SelectTopIntentByDailyRank(startTime int64, endTime int64, n int) (result []map[string]interface{}, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, startTime)
	params = append(params, endTime)
	params = append(params, n)
	generateSQL.WriteString("select intent_id, sum(count) total_cnt, (select intent_name from bot_response where intent_id=di.intent_id order by unix_time desc limit 1) as intent_name from `daily_intent` di where unix_time between ? and ? group by intent_id order by total_cnt desc limit ? ")

	var executeSQL *gorm.DB

	executeSQL = b.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result)
	err = executeSQL.Error
	return
}

func (b botResponseDo) Debug() IBotResponseDo {
	return b.withDO(b.DO.Debug())
}

func (b botResponseDo) WithContext(ctx context.Context) IBotResponseDo {
	return b.withDO(b.DO.WithContext(ctx))
}

func (b botResponseDo) ReadDB() IBotResponseDo {
	return b.Clauses(dbresolver.Read)
}

func (b botResponseDo) WriteDB() IBotResponseDo {
	return b.Clauses(dbresolver.Write)
}

func (b botResponseDo) Session(config *gorm.Session) IBotResponseDo {
	return b.withDO(b.DO.Session(config))
}

func (b botResponseDo) Clauses(conds ...clause.Expression) IBotResponseDo {
	return b.withDO(b.DO.Clauses(conds...))
}

func (b botResponseDo) Returning(value interface{}, columns ...string) IBotResponseDo {
	return b.withDO(b.DO.Returning(value, columns...))
}

func (b botResponseDo) Not(conds ...gen.Condition) IBotResponseDo {
	return b.withDO(b.DO.Not(conds...))
}

func (b botResponseDo) Or(conds ...gen.Condition) IBotResponseDo {
	return b.withDO(b.DO.Or(conds...))
}

func (b botResponseDo) Select(conds ...field.Expr) IBotResponseDo {
	return b.withDO(b.DO.Select(conds...))
}

func (b botResponseDo) Where(conds ...gen.Condition) IBotResponseDo {
	return b.withDO(b.DO.Where(conds...))
}

func (b botResponseDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IBotResponseDo {
	return b.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (b botResponseDo) Order(conds ...field.Expr) IBotResponseDo {
	return b.withDO(b.DO.Order(conds...))
}

func (b botResponseDo) Distinct(cols ...field.Expr) IBotResponseDo {
	return b.withDO(b.DO.Distinct(cols...))
}

func (b botResponseDo) Omit(cols ...field.Expr) IBotResponseDo {
	return b.withDO(b.DO.Omit(cols...))
}

func (b botResponseDo) Join(table schema.Tabler, on ...field.Expr) IBotResponseDo {
	return b.withDO(b.DO.Join(table, on...))
}

func (b botResponseDo) LeftJoin(table schema.Tabler, on ...field.Expr) IBotResponseDo {
	return b.withDO(b.DO.LeftJoin(table, on...))
}

func (b botResponseDo) RightJoin(table schema.Tabler, on ...field.Expr) IBotResponseDo {
	return b.withDO(b.DO.RightJoin(table, on...))
}

func (b botResponseDo) Group(cols ...field.Expr) IBotResponseDo {
	return b.withDO(b.DO.Group(cols...))
}

func (b botResponseDo) Having(conds ...gen.Condition) IBotResponseDo {
	return b.withDO(b.DO.Having(conds...))
}

func (b botResponseDo) Limit(limit int) IBotResponseDo {
	return b.withDO(b.DO.Limit(limit))
}

func (b botResponseDo) Offset(offset int) IBotResponseDo {
	return b.withDO(b.DO.Offset(offset))
}

func (b botResponseDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IBotResponseDo {
	return b.withDO(b.DO.Scopes(funcs...))
}

func (b botResponseDo) Unscoped() IBotResponseDo {
	return b.withDO(b.DO.Unscoped())
}

func (b botResponseDo) Create(values ...*model.BotResponse) error {
	if len(values) == 0 {
		return nil
	}
	return b.DO.Create(values)
}

func (b botResponseDo) CreateInBatches(values []*model.BotResponse, batchSize int) error {
	return b.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (b botResponseDo) Save(values ...*model.BotResponse) error {
	if len(values) == 0 {
		return nil
	}
	return b.DO.Save(values)
}

func (b botResponseDo) First() (*model.BotResponse, error) {
	if result, err := b.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.BotResponse), nil
	}
}

func (b botResponseDo) Take() (*model.BotResponse, error) {
	if result, err := b.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.BotResponse), nil
	}
}

func (b botResponseDo) Last() (*model.BotResponse, error) {
	if result, err := b.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.BotResponse), nil
	}
}

func (b botResponseDo) Find() ([]*model.BotResponse, error) {
	result, err := b.DO.Find()
	return result.([]*model.BotResponse), err
}

func (b botResponseDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.BotResponse, err error) {
	buf := make([]*model.BotResponse, 0, batchSize)
	err = b.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (b botResponseDo) FindInBatches(result *[]*model.BotResponse, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return b.DO.FindInBatches(result, batchSize, fc)
}

func (b botResponseDo) Attrs(attrs ...field.AssignExpr) IBotResponseDo {
	return b.withDO(b.DO.Attrs(attrs...))
}

func (b botResponseDo) Assign(attrs ...field.AssignExpr) IBotResponseDo {
	return b.withDO(b.DO.Assign(attrs...))
}

func (b botResponseDo) Joins(fields ...field.RelationField) IBotResponseDo {
	for _, _f := range fields {
		b = *b.withDO(b.DO.Joins(_f))
	}
	return &b
}

func (b botResponseDo) Preload(fields ...field.RelationField) IBotResponseDo {
	for _, _f := range fields {
		b = *b.withDO(b.DO.Preload(_f))
	}
	return &b
}

func (b botResponseDo) FirstOrInit() (*model.BotResponse, error) {
	if result, err := b.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.BotResponse), nil
	}
}

func (b botResponseDo) FirstOrCreate() (*model.BotResponse, error) {
	if result, err := b.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.BotResponse), nil
	}
}

func (b botResponseDo) FindByPage(offset int, limit int) (result []*model.BotResponse, count int64, err error) {
	result, err = b.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = b.Offset(-1).Limit(-1).Count()
	return
}

func (b botResponseDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = b.Count()
	if err != nil {
		return
	}

	err = b.Offset(offset).Limit(limit).Scan(result)
	return
}

func (b botResponseDo) Scan(result interface{}) (err error) {
	return b.DO.Scan(result)
}

func (b botResponseDo) Delete(models ...*model.BotResponse) (result gen.ResultInfo, err error) {
	return b.DO.Delete(models)
}

func (b *botResponseDo) withDO(do gen.Dao) *botResponseDo {
	b.DO = *do.(*gen.DO)
	return b
}
