// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"strings"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"botApiStats/dal/model"
)

func newDailyIntent(db *gorm.DB, opts ...gen.DOOption) dailyIntent {
	_dailyIntent := dailyIntent{}

	_dailyIntent.dailyIntentDo.UseDB(db, opts...)
	_dailyIntent.dailyIntentDo.UseModel(&model.DailyIntent{})

	tableName := _dailyIntent.dailyIntentDo.TableName()
	_dailyIntent.ALL = field.NewAsterisk(tableName)
	_dailyIntent.ID = field.NewUint(tableName, "id")
	_dailyIntent.UnixTime = field.NewInt64(tableName, "unix_time")
	_dailyIntent.IntentId = field.NewString(tableName, "intent_id")
	_dailyIntent.Count_ = field.NewInt(tableName, "count")

	_dailyIntent.fillFieldMap()

	return _dailyIntent
}

type dailyIntent struct {
	dailyIntentDo

	ALL      field.Asterisk
	ID       field.Uint
	UnixTime field.Int64
	IntentId field.String
	Count_   field.Int

	fieldMap map[string]field.Expr
}

func (d dailyIntent) Table(newTableName string) *dailyIntent {
	d.dailyIntentDo.UseTable(newTableName)
	return d.updateTableName(newTableName)
}

func (d dailyIntent) As(alias string) *dailyIntent {
	d.dailyIntentDo.DO = *(d.dailyIntentDo.As(alias).(*gen.DO))
	return d.updateTableName(alias)
}

func (d *dailyIntent) updateTableName(table string) *dailyIntent {
	d.ALL = field.NewAsterisk(table)
	d.ID = field.NewUint(table, "id")
	d.UnixTime = field.NewInt64(table, "unix_time")
	d.IntentId = field.NewString(table, "intent_id")
	d.Count_ = field.NewInt(table, "count")

	d.fillFieldMap()

	return d
}

func (d *dailyIntent) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := d.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (d *dailyIntent) fillFieldMap() {
	d.fieldMap = make(map[string]field.Expr, 4)
	d.fieldMap["id"] = d.ID
	d.fieldMap["unix_time"] = d.UnixTime
	d.fieldMap["intent_id"] = d.IntentId
	d.fieldMap["count"] = d.Count_
}

func (d dailyIntent) clone(db *gorm.DB) dailyIntent {
	d.dailyIntentDo.ReplaceConnPool(db.Statement.ConnPool)
	return d
}

func (d dailyIntent) replaceDB(db *gorm.DB) dailyIntent {
	d.dailyIntentDo.ReplaceDB(db)
	return d
}

type dailyIntentDo struct{ gen.DO }

type IDailyIntentDo interface {
	gen.SubQuery
	Debug() IDailyIntentDo
	WithContext(ctx context.Context) IDailyIntentDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IDailyIntentDo
	WriteDB() IDailyIntentDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IDailyIntentDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IDailyIntentDo
	Not(conds ...gen.Condition) IDailyIntentDo
	Or(conds ...gen.Condition) IDailyIntentDo
	Select(conds ...field.Expr) IDailyIntentDo
	Where(conds ...gen.Condition) IDailyIntentDo
	Order(conds ...field.Expr) IDailyIntentDo
	Distinct(cols ...field.Expr) IDailyIntentDo
	Omit(cols ...field.Expr) IDailyIntentDo
	Join(table schema.Tabler, on ...field.Expr) IDailyIntentDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IDailyIntentDo
	RightJoin(table schema.Tabler, on ...field.Expr) IDailyIntentDo
	Group(cols ...field.Expr) IDailyIntentDo
	Having(conds ...gen.Condition) IDailyIntentDo
	Limit(limit int) IDailyIntentDo
	Offset(offset int) IDailyIntentDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IDailyIntentDo
	Unscoped() IDailyIntentDo
	Create(values ...*model.DailyIntent) error
	CreateInBatches(values []*model.DailyIntent, batchSize int) error
	Save(values ...*model.DailyIntent) error
	First() (*model.DailyIntent, error)
	Take() (*model.DailyIntent, error)
	Last() (*model.DailyIntent, error)
	Find() ([]*model.DailyIntent, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.DailyIntent, err error)
	FindInBatches(result *[]*model.DailyIntent, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.DailyIntent) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IDailyIntentDo
	Assign(attrs ...field.AssignExpr) IDailyIntentDo
	Joins(fields ...field.RelationField) IDailyIntentDo
	Preload(fields ...field.RelationField) IDailyIntentDo
	FirstOrInit() (*model.DailyIntent, error)
	FirstOrCreate() (*model.DailyIntent, error)
	FindByPage(offset int, limit int) (result []*model.DailyIntent, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IDailyIntentDo
	UnderlyingDB() *gorm.DB
	schema.Tabler

	FilterWithNameAndRole(name string, role string) (result []model.DailyIntent, err error)
	SelectTopIntentId(n int) (result []map[string]interface{}, err error)
	SelectTopIntentIdByTime(startTime int64, endTime int64, n int) (result []map[string]interface{}, err error)
	GetIntentNameByIntentId(intentId string) (result string, err error)
	SelectTopIntentByDailyRank(startTime int64, endTime int64, n int) (result []map[string]interface{}, err error)
	SelectNewestIntentNamesByIntentIds(intentIds []string) (result []string, err error)
	SelectIntentIdMapIntentName() (result map[string]string, err error)
}

// SELECT * FROM @@table WHERE name = @name{{if role !=""}} AND role = @role{{end}}
func (d dailyIntentDo) FilterWithNameAndRole(name string, role string) (result []model.DailyIntent, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, name)
	generateSQL.WriteString("SELECT * FROM daily_intent WHERE name = ? ")
	if role != "" {
		params = append(params, role)
		generateSQL.WriteString("AND role = ? ")
	}

	var executeSQL *gorm.DB

	executeSQL = d.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result)
	err = executeSQL.Error
	return
}

// select intent_id, count(*) cnt from `bot_response` group by intent_id order by cnt desc limit @n
func (d dailyIntentDo) SelectTopIntentId(n int) (result []map[string]interface{}, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, n)
	generateSQL.WriteString("select intent_id, count(*) cnt from `bot_response` group by intent_id order by cnt desc limit ? ")

	var executeSQL *gorm.DB

	executeSQL = d.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result)
	err = executeSQL.Error
	return
}

// select intent_id, count(*) cnt,
// (select intent_name from bot_response where intent_id=br.intent_id  order by unix_time desc limit 1) as intent_name
// from `bot_response` br where unix_time between @startTime and @endTime group by intent_id order by cnt desc limit @n
func (d dailyIntentDo) SelectTopIntentIdByTime(startTime int64, endTime int64, n int) (result []map[string]interface{}, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, startTime)
	params = append(params, endTime)
	params = append(params, n)
	generateSQL.WriteString("select intent_id, count(*) cnt, (select intent_name from bot_response where intent_id=br.intent_id order by unix_time desc limit 1) as intent_name from `bot_response` br where unix_time between ? and ? group by intent_id order by cnt desc limit ? ")

	var executeSQL *gorm.DB

	executeSQL = d.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result)
	err = executeSQL.Error
	return
}

// select intent_name from bot_response where intent_id = @intentId order by created_at desc limit 1
func (d dailyIntentDo) GetIntentNameByIntentId(intentId string) (result string, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, intentId)
	generateSQL.WriteString("select intent_name from bot_response where intent_id = ? order by created_at desc limit 1 ")

	var executeSQL *gorm.DB

	executeSQL = d.UnderlyingDB().Raw(generateSQL.String(), params...).Take(&result)
	err = executeSQL.Error
	return
}

// select intent_id, sum(count) total_cnt,
// (select intent_name from bot_response where intent_id=di.intent_id order by unix_time desc limit 1) as intent_name
// from `daily_intent` di where unix_time between @startTime and @endTime group by intent_id order by total_cnt desc limit @n
func (d dailyIntentDo) SelectTopIntentByDailyRank(startTime int64, endTime int64, n int) (result []map[string]interface{}, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, startTime)
	params = append(params, endTime)
	params = append(params, n)
	generateSQL.WriteString("select intent_id, sum(count) total_cnt, (select intent_name from bot_response where intent_id=di.intent_id order by unix_time desc limit 1) as intent_name from `daily_intent` di where unix_time between ? and ? group by intent_id order by total_cnt desc limit ? ")

	var executeSQL *gorm.DB

	executeSQL = d.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result)
	err = executeSQL.Error
	return
}

// select intent_name from (select * from `bot_response` order by unix_time desc limit 100000000) as b
// where intent_id in (@intentIds)  group by intent_id order by field(intent_id {{for _,id:=range intentIds}},@id{{end}} )
func (d dailyIntentDo) SelectNewestIntentNamesByIntentIds(intentIds []string) (result []string, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, intentIds)
	generateSQL.WriteString("select intent_name from (select * from `bot_response` order by unix_time desc limit 100000000) as b where intent_id in (?) group by intent_id order by field(intent_id ")
	for _, id := range intentIds {
		params = append(params, id)
		generateSQL.WriteString(",? ")
	}
	generateSQL.WriteString(") ")

	var executeSQL *gorm.DB

	executeSQL = d.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result)
	err = executeSQL.Error
	return
}

// select intent_id, intent_name from (select * from `bot_response` order by unix_time desc limit 100000000) as b  group by intent_id
func (d dailyIntentDo) SelectIntentIdMapIntentName() (result map[string]string, err error) {
	var generateSQL strings.Builder
	generateSQL.WriteString("select intent_id, intent_name from (select * from `bot_response` order by unix_time desc limit 100000000) as b group by intent_id ")

	result = make(map[string]string)
	var executeSQL *gorm.DB

	executeSQL = d.UnderlyingDB().Raw(generateSQL.String()).Take(result)
	err = executeSQL.Error
	return
}

func (d dailyIntentDo) Debug() IDailyIntentDo {
	return d.withDO(d.DO.Debug())
}

func (d dailyIntentDo) WithContext(ctx context.Context) IDailyIntentDo {
	return d.withDO(d.DO.WithContext(ctx))
}

func (d dailyIntentDo) ReadDB() IDailyIntentDo {
	return d.Clauses(dbresolver.Read)
}

func (d dailyIntentDo) WriteDB() IDailyIntentDo {
	return d.Clauses(dbresolver.Write)
}

func (d dailyIntentDo) Session(config *gorm.Session) IDailyIntentDo {
	return d.withDO(d.DO.Session(config))
}

func (d dailyIntentDo) Clauses(conds ...clause.Expression) IDailyIntentDo {
	return d.withDO(d.DO.Clauses(conds...))
}

func (d dailyIntentDo) Returning(value interface{}, columns ...string) IDailyIntentDo {
	return d.withDO(d.DO.Returning(value, columns...))
}

func (d dailyIntentDo) Not(conds ...gen.Condition) IDailyIntentDo {
	return d.withDO(d.DO.Not(conds...))
}

func (d dailyIntentDo) Or(conds ...gen.Condition) IDailyIntentDo {
	return d.withDO(d.DO.Or(conds...))
}

func (d dailyIntentDo) Select(conds ...field.Expr) IDailyIntentDo {
	return d.withDO(d.DO.Select(conds...))
}

func (d dailyIntentDo) Where(conds ...gen.Condition) IDailyIntentDo {
	return d.withDO(d.DO.Where(conds...))
}

func (d dailyIntentDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IDailyIntentDo {
	return d.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (d dailyIntentDo) Order(conds ...field.Expr) IDailyIntentDo {
	return d.withDO(d.DO.Order(conds...))
}

func (d dailyIntentDo) Distinct(cols ...field.Expr) IDailyIntentDo {
	return d.withDO(d.DO.Distinct(cols...))
}

func (d dailyIntentDo) Omit(cols ...field.Expr) IDailyIntentDo {
	return d.withDO(d.DO.Omit(cols...))
}

func (d dailyIntentDo) Join(table schema.Tabler, on ...field.Expr) IDailyIntentDo {
	return d.withDO(d.DO.Join(table, on...))
}

func (d dailyIntentDo) LeftJoin(table schema.Tabler, on ...field.Expr) IDailyIntentDo {
	return d.withDO(d.DO.LeftJoin(table, on...))
}

func (d dailyIntentDo) RightJoin(table schema.Tabler, on ...field.Expr) IDailyIntentDo {
	return d.withDO(d.DO.RightJoin(table, on...))
}

func (d dailyIntentDo) Group(cols ...field.Expr) IDailyIntentDo {
	return d.withDO(d.DO.Group(cols...))
}

func (d dailyIntentDo) Having(conds ...gen.Condition) IDailyIntentDo {
	return d.withDO(d.DO.Having(conds...))
}

func (d dailyIntentDo) Limit(limit int) IDailyIntentDo {
	return d.withDO(d.DO.Limit(limit))
}

func (d dailyIntentDo) Offset(offset int) IDailyIntentDo {
	return d.withDO(d.DO.Offset(offset))
}

func (d dailyIntentDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IDailyIntentDo {
	return d.withDO(d.DO.Scopes(funcs...))
}

func (d dailyIntentDo) Unscoped() IDailyIntentDo {
	return d.withDO(d.DO.Unscoped())
}

func (d dailyIntentDo) Create(values ...*model.DailyIntent) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Create(values)
}

func (d dailyIntentDo) CreateInBatches(values []*model.DailyIntent, batchSize int) error {
	return d.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (d dailyIntentDo) Save(values ...*model.DailyIntent) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Save(values)
}

func (d dailyIntentDo) First() (*model.DailyIntent, error) {
	if result, err := d.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.DailyIntent), nil
	}
}

func (d dailyIntentDo) Take() (*model.DailyIntent, error) {
	if result, err := d.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.DailyIntent), nil
	}
}

func (d dailyIntentDo) Last() (*model.DailyIntent, error) {
	if result, err := d.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.DailyIntent), nil
	}
}

func (d dailyIntentDo) Find() ([]*model.DailyIntent, error) {
	result, err := d.DO.Find()
	return result.([]*model.DailyIntent), err
}

func (d dailyIntentDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.DailyIntent, err error) {
	buf := make([]*model.DailyIntent, 0, batchSize)
	err = d.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (d dailyIntentDo) FindInBatches(result *[]*model.DailyIntent, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return d.DO.FindInBatches(result, batchSize, fc)
}

func (d dailyIntentDo) Attrs(attrs ...field.AssignExpr) IDailyIntentDo {
	return d.withDO(d.DO.Attrs(attrs...))
}

func (d dailyIntentDo) Assign(attrs ...field.AssignExpr) IDailyIntentDo {
	return d.withDO(d.DO.Assign(attrs...))
}

func (d dailyIntentDo) Joins(fields ...field.RelationField) IDailyIntentDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Joins(_f))
	}
	return &d
}

func (d dailyIntentDo) Preload(fields ...field.RelationField) IDailyIntentDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Preload(_f))
	}
	return &d
}

func (d dailyIntentDo) FirstOrInit() (*model.DailyIntent, error) {
	if result, err := d.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.DailyIntent), nil
	}
}

func (d dailyIntentDo) FirstOrCreate() (*model.DailyIntent, error) {
	if result, err := d.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.DailyIntent), nil
	}
}

func (d dailyIntentDo) FindByPage(offset int, limit int) (result []*model.DailyIntent, count int64, err error) {
	result, err = d.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = d.Offset(-1).Limit(-1).Count()
	return
}

func (d dailyIntentDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = d.Count()
	if err != nil {
		return
	}

	err = d.Offset(offset).Limit(limit).Scan(result)
	return
}

func (d dailyIntentDo) Scan(result interface{}) (err error) {
	return d.DO.Scan(result)
}

func (d dailyIntentDo) Delete(models ...*model.DailyIntent) (result gen.ResultInfo, err error) {
	return d.DO.Delete(models)
}

func (d *dailyIntentDo) withDO(do gen.Dao) *dailyIntentDo {
	d.DO = *do.(*gen.DO)
	return d
}
